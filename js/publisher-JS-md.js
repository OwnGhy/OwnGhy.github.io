(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[7],{

/***/ 40:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("<!--title: JS正则实践记录-->\n<!--date: 2018.12.11-->\n<!--cate: 1-->\n正则一直是我的弱项，基本的知识看了好几遍，但是当需求来了的时候，往往还是不能正确的使用正则去处理问题，常常都是在网上搜索的答案😢。\n\n为了掌握正则，在这里记录自己平时遇到的一些正则需求，以及使用方法，通过越来越多的使用，希望能真的掌握正则。\n\n另：由于我基础真的不好，所以都写得很基础😢，目的在于能巩固一下。`啰嗦预警~`\n\n> 关于正则的概念与基础的学习，可以参考这篇文章[JS正则表达式完整教程（略长）](https://juejin.im/post/5965943ff265da6c30653879#heading-0)，写得比较系统完整，非常棒呀，终于系统的学习正则了。\n\n<!-- more -->\n## 实际需求类\n\n### 获取URL的查询参数\n之前获取url的查询参数都是用的第三方的工具，其实要自己匹配获取还是很简单的。\n\n```\n// ?name=nancy&id=123\nlet query = {};\nlocation.search.replace(/([^?&=]+)=([^&]+)/g, ($0, $1, $2) => query[$1] = $2);\nconsole.log(query);  // { name: 'nancy', id: '123' }\n```\n解析，主要是两个分组和一个`=`：\n\n- `([^?&=]+)`：这个分组用于匹配查询参数的key，`[^?&=]`这个反向字符集中表示，key不能包括`?`、`&`或者`=`，达到去除这三个符号的目的\n- `=`：用`=`间隔key和value\n- `([^&]+)`：这一个分组和前一个分组差不多，只不过不包括`?`因为后面的value不会出现`?`，只在第一个字符出现\n\n通过replace的方法，将匹配的到key和value赋值到结果query中，目的达到啦✌️。\n\n### 匹配16进制颜色值\n```\nconst reg = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;\n\nconst colors = '#ad4 #eee #ffffff #123fff';\n\nconsole.log(colors.match(reg));\n// [\"#ad4\", \"#eee\", \"#ffffff\", \"#123fff\"]\n```\n解析：\n\n- `#`：16进制颜色以`#`开头\n- `[0-9a-fA-F]`：匹配16进制字符\n- `{6}`和`{3}`： 16进制颜色可以是6位的，也可以是3位的缩写， `|`表示可选，需要注意的是，`{6}`在`{3}`前面，是为了避免匹配6位时提前结束匹配\n\n### 匹配元素的id\n需求，一个字符串中包含一个元素，要求匹配该字符串中元素的id。\n\n```\nconst element = '<div id=\"test\"></div>';\nconst reg = /id=\".*\"/\nconsole.log(element.match(reg));\n// id=\"test\"\n```\n上面的正则很简单，就是匹配`id=\"`后带有任意字符任意次数，且以`\"`结尾的字符串。\n\n但是❗️，需要注意的是，量词`*`是**贪婪**的，上面的元素id匹配没有问题，但是当元素字符串为`<div id=\"test\" class=\"content\"></div>`的时候，上面的正则匹配结果是`id=\"test\" class=\"content\"`，因为`*`的贪婪模式，且通配符`.`中也包括了`\"`，所以正则会在匹配最后一个`\"`的时候才结束匹配。\n\n解决方法：\n\n```\nconst element = '<div id=\"test\" class=\"content\"></div>';\nconst reg = /id=\".*?\"/\nconsole.log(element.match(reg));  // id=\"test\"\n```\n解析，核心是惰性匹配：\n\n- `*?`：在`*`后面添加`?`即惰性模式，表示尽可能少的去匹配，当匹配到第一个`\"`时，将其归纳为尾部的`\"`\n\n但是上面的做法效率比较低，会涉及到“回溯”这个概念。所以可以优化：\n\n```\nconst element = '<div id=\"test\" class=\"content\"></div>';\nconst reg = /id=\"[^\"]\"/\nconsole.log(element.match(reg));\n// id=\"test\"\n```\n解析：\n\n- `[^\"]`：使用反向字符集去排除`\"`即可\n\n> 回溯，也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。\n> \n> 关于更多关于正则回溯的解释可以参考最开始提过的文章：[JS正则表达式完整教程（略长）](https://juejin.im/post/5965943ff265da6c30653879#heading-21)\n\n### 中括号内容及中括号加粗\n#### 场景\n需求是对系统用户的操作进行记录，后端会将操作描述拼接为`[张三]创建账单[213]`这样的字符串，在前端拿到之后需要进行处理，将中括号及中括号中的内容加粗。\n\n```\ntext.replace(/\\[[^\\[\\]]*]/g,$0 => {\n\treturn `<b>${$0}</b>`;\n})\n// <b>[张三]</b>创建账单<b>[213]</b>\n```\n上面的代码可以正确的匹配并得到结果。\n\n解析：\n\n- `\\[`：`[`是特殊符号，需要转义\n- `[^\\[\\]]*`:`[^]`表示反向字符集，在反向字符集中添加`\\[\\]`表示不匹配`[`和`]`，以避免嵌套中括的情况，`*`表示不是`[`和`]`的字符可以出现任意次数\n- `]`：表示结尾的匹配，需要注意的是`]`不是特殊字符，可以不用转移，但是在上一步的反向字符集中，为了区分反向字符集的结尾，所以进行了转义\n\n#### 拓展\n上面的正则，如果中括号出现嵌套的情况，例如：`[[张三]]创建账单[213]`会替换成`[<b>[张三]</b>创建账单<b>[213]</b>`，只会匹配最内层的中括号，那么如何匹配最外层的中括号呢？\n\n```\ntext.replace(/\\[[^\\]]*]*/g,$0 => {\n\treturn `<b>${$0}</b>`;\n})\n// \"<b>[[张三]]</b>创建账单<b>[213]</b>\"\n```\n\n解析，最大的区别在于下面两点：\n- `[^\\]]`：反向字符集中去除了`\\[`，以达到可以包括`[`的目的，但是依旧包含`\\]`是为了在遇到第一个`]`的时候继续匹配\n- `]*`： 尾部的结束可以多个`]`，这样避免了在遇到多个`]`的时候正则匹配提前结束，如果不添加`]*`的情况，那么最后的匹配结果将是`<b>[[张三]</b>]创建账单<b>[213]</b>`，导致遇到第一个中括号提前结束，以致匹配错误\n\n### 数字的千位分隔符表示\n```\nconst reg = /(?!^)(?=(\\d{3})+$)/g;\nconst numStr = '123456789';\nconsole.log(numStr.replace(reg, ','));\n// 123,456,789\n```\n解析：\n\n`(?=(\\d{3})+$)`： 首先`(?=p)`是位置匹配模式，子模式 p 这里是`(\\d{3})+$`，`(\\d{3})+`表示每三位数字为一组，`$`在这里有从尾部开始匹配的含义。所以这一组的含义就是匹配每三位数字前的位置。\n`(?!^) `：这一正则的含义是匹配的位置不能是开头，是为了解决 123456 匹配成 ,123,456 的情况。\n\n## 数字类\n待续...\n\n## 正则sao操作\n### 匹配任意字符\n我们知道`.`表示匹配任务字符，除了换行符、回车符、行分隔符和段分隔符，等同于`[^\\n\\r\\u2028\\u2029]`，要匹配任意字符可以用：`[\\d\\D]`、`[\\w\\W]`、`[\\s\\S]`和`[^]`，反正我觉得是有点sao的🤣。\n\n### 不匹配任何字符的正则\nemm...正则不就是要匹配嘛，你让我不匹配任何字符？？？有意思嘛😂。\n\n不过我还真在网上看到这个正则：`/.^/`。该正则就可以不匹配任何字符。该正则要求只有一个任意字符且，在开头之前，所有就是不匹配任何字符了🤣。");

/***/ })

}]);
//# sourceMappingURL=publisher-JS-md.js.map